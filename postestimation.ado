//
// wrapper
//

cap program drop nopopost
program define nopopost, eclass

    syntax [namelist] [if] [in] [fweight pweight iweight], ///
        [by(varlist max=1) *] ///
		[atc att]

	/*
	 In essence, this wrapper does two things:

	 (1) Call a Nopo (2008) style decomposition after matching via kmatch. If a varlist is
	     specified, this wrapper calls a basic cem version of kmatch, otherwise it checks if all requirements are met by the kmatch performed before nopopost. Estimates are returned for
		 the decomposition components and a few auxiliary things.
	 (2) Call postestimation stuff:
	 	 - plot gap components over the outcome distribution
		 - plot contributions to DA/DB by variable level
		 - show summary table by group (A_unmatched, A_matched, A_matched^B / B_matched^A, B_matched, B_unmatched); atm only mean (sd)

	*/

	// tokenize; determine decomp operation
	if ("`namelist'" != "") gettoken subcmd varlist : namelist
		else local subcmd "decomp"
	if (!inlist("`subcmd'", "decomp", "gapoverdist", "dadb", "summarize")) {
		dis as error "nopopost subcommand must be one of:"
		dis as error "'decomp', 'gapoverdist', 'dadb', 'summarize'"
		error 198
		exit
	}

	// ATT/ATC check
	if ("`atc'" != "" & "`att'" != "") {
		dis as error "Specify either 'ate' or 'atc' as options, not both."
		error 198
		exit
	}

	// run kmatch or check if kmatch requirements met
	if ("`subcmd'" == "decomp" & "`varlist'" != "") {
		local nvars : word count `varlist'
		if (`nvars' == 1) {
			dis as error "'nopopost decomp `varlist'' invalid. Valid options are:"
			dis as error "(1) Provide at least one matching variable in addition to depvar `varlist'."
			dis as error "(2) Use only 'nopopost decomp' after running 'kmatch'"
			error 100
			exit
		}
		else if ("`by'" == "") {
				dis as error "Option 'by(groupvar)' required for decomposition."
				error 102
				exit
		}
		else {
			if ("`atc'" == "" & "`att'" == "") {
				dis "Estimating default ATT."
				local att = "att"
			}
			// most simple spec! anything else will require running kmatch prior
			gettoken _depvar varlist : varlist
			if ("`weight'" != "") local _weightexp "[`weight'`exp']"
			qui kmatch em `by' `varlist' (`_depvar') `if' `in' `_weightexp' ///
				, `atc' `att' generate wgenerate replace
			// save matching weight variable for passthru
			local _mweight = "mweight(`e(wgenerate)')" // only one possible
			// clear varlist
			local varlist
		}
	}
	else if ("`subcmd'" == "decomp" & "`varlist'" == "") {
		// check if prior command was kmatch
		if ("`e(cmd)'" != "kmatch") {
			dis as error "Previous command was not kmatch."
			error 301
			exit
		} 
		else if (!inlist("`e(subcmd)'", "md", "ps", "em")) {
			dis as error "nopopost only works after kmatch md, kmatch ps, and kmatch em."
			error 301
			exit
		}
		else if ("`e(att)'" == "" & "`att'" != "") {
			dis as error "No kmatch estimates found for ATT (use kmatch option 'att')."
			error 301
			exit
		}
		else if ("`e(atc)'" == "" & "`atc'" != "") {
			dis as error "No kmatch estimates found for ATC (use kmatch option 'atc')."
			error 301
			exit
		}
		else if (e(N_over) > 1 | "`e(ovar2)'" != "") {
			dis as error "nopopost requires kmatch to be specifcied with a single outcome (ovar) and without the 'over()' option."
			error 301
			exit
		}
		else if ("`e(generate)'" == "" | "`e(wgenerate)'" == "") {
			// rerun with matching variables if missing
			dis "nopopost requires matching variables generated by kmatch. Re-running with options 'generate' and 'wgenerate'..."
			local _cmdline `" `e(cmdline)' "'
			if ("`e(generate)'" == "") local _cmdline `" `_cmdline' generate "' 
			if ("`e(wgenerate)'" == "") local _cmdline `" `_cmdline' wgenerate "'
			if (strpos(`"`_cmdline'"', " replace") == 0) local _cmdline `" `_cmdline' replace "'
			qui `_cmdline'
		}

		// save matching weight variable for passthru (flexible approach to prior kmatch specs)
		local _idx = 1
		if ("`e(ate)'" != "") local ++_idx // if ate present, jump to next word in weight list
		if ("`e(att)'" != "" & "`atc'" != "") local ++_idx // defaults to att
		local _mweight : word `_idx' of `e(wgenerate)'
		local _mweight "mweight(`_mweight')"

	}

	// run subcommand with option passthru
	nopopost_`subcmd' `varlist', `_mweight' `atc' `att' `options'

end


//
// Nopo (2008) style decomposition
//

cap program drop nopopost_decomp
program define nopopost_decomp, eclass

    syntax , ///
		mweight(varlist max=1) ///
		[att atc] ///
        [REVerse] // reverse direction of coefficients

	quietly {
		
		//
		// use returns of kmatch for estimations or passthru
		//

		// depvar
        local _depvar = e(depvar)
		// treatment
        local _tvar = e(tvar)
		local _tval = e(tval)
        tempvar treat // fix treatment tempvar to 0/1
		gen `treat' = 0 if !mi(`_tvar')
        replace `treat' = 1 if `_tvar' == `_tval'
		// determine matching set from kmatch for return passthru; drop doublettes
		local _varset "`e(xvars)' `e(emvars)' `e(emxvars)'" // varnames = tokenizable as regex words'
		foreach _w in `_varset' {
			gettoken _word _rest : _varset
			// save first occurence
			local _matchset "`_matchset' `_word'"
			// delete the rest
			if (ustrregexm("`_rest'", "\b`_word'\b") == 1) {
				local _varset = ustrregexra("`_rest'", "\b`_word'\b", "")
			} 
		}
		local _matchset = strrtrim(strltrim(stritrim("`_matchset'")))
		// weights
		if ("`e(wtype)'" != "") {
			local _wtype = e(wtype)
			local _wexp = e(wexp)
			local _weightexp = "[`_wtype'`_wexp']"
			if ("`_wtype'" == "pweight") local _sum_weightexp = "[aw`_wexp']"
				else local _sum_weightexp = `_weightexp'
			}
		if ("`e(vce)'" == "analytic") local vce = "ols"
			else local vce = e(vce)
		// generated matching vars processing
		tokenize `e(generate)'
		tempvar matched
		gen `matched' = 0 if `2' == 0 | `3' == 0
		replace `matched' = 1 if (`2' > 0 & !mi(`2')) | (`3' > 0 & !mi(`3'))
		local _strata = "`5'"
		levelsof `_strata', matrow(strata)
		scalar _nstrata = rowsof(strata)
		levelsof `_strata' if `matched' == 1, matrow(strata)
		scalar _nmstrata = rowsof(strata)
		// sample
		tempvar sample
		gen `sample' = e(sample)
		local N = e(N)
		mat Nsupport = e(_N)

		//
		// gather/estimate components
		//
		
		// placeholder matrices: D, D0, DA, DB
		mat b4 = J(1, 4, .)
		matname b4 D D0 DA DB, columns(1..4) explicit
		mat V4 = J(1, 4, .)
		matname V4 D D0 DA DB, columns(1..4) explicit
		
		// D0 (directly from kmatch)
		if ("`att'" != "") local _TE "ATT"
			else local _TE "ATC"
		mat b = e(b)[1, "`_TE'"]
		mat b4[1,2] = b[1,1]
		mat V = e(V)["`_TE'", "`_TE'"]
		mat V4[1,2] = V[1,1]
		
		// D
		reg `_depvar' i.`treat' `_weightexp' if `sample', vce(`vce')
		mat b = e(b)
		mat b4[1,1] = b[1,2]
		mat V = e(V)
		mat V4[1,1] = V[2,2]
		
		// DA
		sum `_depvar' if `treat' == 0 & `matched' == 0 & `sample' `_sum_weightexp'
		local n1 = r(sum_w)
		sum `_depvar' if `treat' == 0 & `sample' `_sum_weightexp'
		local n2 = r(sum_w)
		reg `_depvar' i.`matched' if `treat' == 0 & `sample' `_weightexp', vce(`vce')
		scalar _mgapA = _b[1.`matched']
		nlcom _b[1.`matched'] * (`n1'/`n2'), post
		scalar _msharewA = (1 - `n1' / `n2') * 100
		mat b = e(b)
		mat b4[1,3] = b[1,1]
		mat V = e(V)
		mat V4[1,3] = V[1,1]

		// DB
		sum `_depvar' if `treat' == 1 & `matched' == 0 & `sample' `_sum_weightexp'
		local n1 = r(sum_w)
		sum `_depvar' if `treat' == 1 & `sample' `_sum_weightexp'
		local n2 = r(sum_w)
		reg `_depvar' i.`matched' if `treat' == 1 & `sample' `_weightexp', vce(`vce')
		scalar _mgapB = _b[1.`matched']
		nlcom _b[1.`matched'] * -1 * (`n1'/`n2'), post
		scalar _msharewB = (1 - `n1' / `n2') * 100
		mat b = e(b)
		mat b4[1,4] = b[1,1]
		mat V = e(V)
		mat V4[1,4] = V[1,1]
		
		// estimate DX from other components in the same model
		mat b5 = b4[1,1], b4[1,2], ., b4[1,3], b4[1,4]
		matname b5 D D0 DX DA DB, columns(1..5) explicit
		mat V5 = V4[1,1], V4[1,2], ., V4[1,3], V4[1,4]
		matname V5 D D0 DX DA DB, columns(1..5) explicit
		mat V4 = diag(V4)
		ereturn post b4 V4
		nlcom (_b[D] - _b[D0] - _b[DA] - _b[DB]), post
		mat b = e(b)
		mat b5[1,3] = b[1,1]
		mat V = e(V)
		mat V5[1,3] = V[1,1]
		mat V5 = diag(V5)
        
        // reverse gap direction?
        if ("`reverse'" != "") {
            mat b5 = b5 * -1
        }
		
		// N
		scalar _nA = Nsupport[1,3]
		scalar _nB = Nsupport[1,6]
		scalar _mshareuwA = Nsupport[1,1] / Nsupport[1,3] * 100
		scalar _mshareuwB = Nsupport[1,4] / Nsupport[1,6] * 100
		
		// return
		/*
		 Things to do: We could return a nice table in the style you already prepared.
		*/
		ereturn post b5 V5, obs(`N') esample(`sample') depname(`_depvar')
		ereturn local cmd = "nopopost"
		ereturn local subcmd = "`subcmd'"
		//ereturn matrix match_table = mtab
		ereturn local teffect = "`_TE'"
		ereturn local tvar = "`_tvar'"
		ereturn local tval = "`_tval'"
		ereturn local matchset = strltrim("`_matchset'")
		ereturn local strata = "`_strata'"
		ereturn scalar nstrata = _nstrata
		ereturn scalar nstratA_matchedatched = _nmstrata
		ereturn local matched = "_matched"
		cap drop _matched
		rename `matched' _matched
		lab var _matched "Matching indicator (dummy)"
		ereturn matrix _N = Nsupport
		ereturn scalar nA = _nA
		ereturn scalar mshareuwA = _mshareuwA // unweighted
		ereturn scalar msharewA = _msharewA // weighted
		ereturn scalar mgapA = _mgapA // raw diff by matching status
		ereturn scalar nB = _nB
		ereturn scalar mshareuwB = _mshareuwB // unweighted
		ereturn scalar msharewB = _msharewB // weighted
        ereturn scalar mgapB = _mgapB // raw diff by matching status
		if ("`_wtype'" != "") {
			ereturn local wtype = "`_wtype'"
			ereturn local wexp = "`_wexp'"
		}
		ereturn local mweight = "`mweight'"
	}
	
	// display results
	ereturn display, noomitted
	
end


//
// Plot gap component over dv distribution
//

/*

At the moment, the plot shows the gaps by comparing the outcome means in each quantile between 
groups. So, the mean across all these comparisons is the same as the decomposition component values
produced by nopo. But that also means that:

- At each quantile, the single component values do not add up to d
- D_A and D_B are scaled as in the nopo decomp, so higher values can mean more people or larger gaps
  (though the factor is always the same due to the quantile logic: n0/(n0+n1) is the same for each
  quantile). The `rawumdiff' option circumvents the scaling and shows the absolute differences,
  but then the values do not sum up to D_A/D_B

Does that sound sensible?

*/

// gap over distribution plotting wrapper: 5 plots needed (one for each gap component)
cap program drop nopopost_gapoverdist
program define nopopost_gapoverdist
syntax [if] [in], /// might produce strange results if if/in are used
	[NQuantiles(integer 100)] ///
	[QMIN(integer 1)] ///
	[QMAX(integer 100)] ///
	[RAWUMdiff] ///
	[twtype(string)] ///
	[twopts(string asis)] ///
	[twoptsd(string asis)] ///
	[twoptsd0(string asis)] ///
	[twoptsdx(string asis)] ///
	[twoptsda(string asis)] ///
	[twoptsdb(string asis)] ///
	[nodraw] ///
	[SAVE(string asis)]

	quietly {

		// check if prior command was nopo
		if ("`e(cmd)'" != "nopopost") {
			noisily dis as error "Previous command was not nopopost decomp."
			error 301
			exit
		}

		// set input from syntax and nopo returns
		// sample
		tempvar touse
		mark `touse' `if' `in'
		replace `touse' = 0 if !e(sample)
		// depvar
		local _depvar = e(depvar)
		// treatment indicator (fix to 0/1)
		tempvar treat
		gen `treat' = 1 if `e(tvar)' == `e(tval)'
		replace `treat' = 0 if `treat' != 1 & !mi(`e(tvar)')
		// b reference
		if ("`e(teffect)'" == "ATC") local _bref = 1
			else local _bref = 0
		// support
		local _support = e(matched)
		// matching weights
		local _mweight = e(mweight)
		// weights
		if ("`e(wtype)'" != "") {
			local _weightexp "[`e(wtype)' = `e(wexp)']"
		}
		else {
			tempvar w1
			gen `w1' = 1
			local _weightexp "[pw = `w1']"
		}

		// set defaults
		if ("`twtype'" == "") local twtype "line"
		if (`"`twopts'"' == "") local twopts `" legend(order(1 "D" 2 "DX" 3 "D0" 4 "DA" 5 "DB") rows(1) span) yline(0) scheme(s1mono) ylab(, angle(horizontal)) xlab(, grid) ylab(, grid)"'
		if ("`twtype'" == "line") {
			if (`"`twoptsd'"' == "") local twoptsd "lp(solid) lw(0.5)"
			if (`"`twoptsd0'"' == "") local twoptsd0 "lp(shortdash)"
			if (`"`twoptsdx'"' == "") local twoptsdx "lp(dash)"
			if (`"`twoptsda'"' == "") local twoptsda "lp(dash_dot)"
			if (`"`twoptsdb'"' == "") local twoptsdb "lp(longdash_dot)"
		}

		// abort if quantiles > depvar groups
		qui levelsof `_depvar' if `touse', local(depvarlvls)
		local nqlvls : word count `depvarlvls'
		if (`nquantiles' > `nqlvls') {
			noisily dis as error "Groups in `_depvar' < quantiles requested (`nquantiles')."
			error 148
			exit
		}

		// options passthru
		local opts `"nq(`nquantiles') qmin(`qmin') qmax(`qmax') `revsign' `relative'"'

		// create plot values for each component
		// D
		tempfile d
		nopopost_gapdist `_depvar' if `touse' `_weightexp', by(`treat') `opts' save(`d')
		// D0
		tempfile d0
		nopopost_gapdist `_depvar' if `touse' & `_support' [pw = `_mweight'] ///
			, by(`treat') `opts' save(`d0')
		// DX (requires passing of matching weight)
		tempfile dx
		nopopost_gapdist `_depvar' if `touse' & `_support' `_weightexp' ///
			, by(`treat') bref(`_bref') comp(dx) mweight(`_mweight') `opts' save(`dx')
		// DA
		tempfile da
		nopopost_gapdist `_depvar' if `touse' & `treat' == 0 `_weightexp' ///
			, by(`_support') comp(da) `rawumdiff' `opts' save(`da')
		// DB
		tempfile db
		nopopost_gapdist `_depvar' if `touse' & `treat' == 1 `_weightexp' ///
			, by(`_support') comp(db) `rawumdiff' `opts' save(`db')

		// output
		preserve
			use "`d'", clear
			rename diff d
			foreach c in d0 dx da db {
				merge 1:1 q using "``c''", nogen
				rename diff `c'
			}
			// checking
			noisily {
				dis "Check means over component quantiles (some precision lost):"
				sum d d0 dx da db
			}
			// plot
			if ("`nodraw'" == "") {
				twoway ///
					(`twtype' d q, `twoptsd') ///
					(`twtype' d0 q, `twoptsd0') ///
					(`twtype' dx q, `twoptsdx') ///
					(`twtype' da q, `twoptsda') ///
					(`twtype' db q, `twoptsdb') ///
					, `twopts'
			}
			// save if requested
			if (`"`save'"' != "") noisily save `save', replace
		restore
	}

end

// get nopo decomposition component values over distribution of depvar
cap program drop nopopost_gapdist
program define nopopost_gapdist
syntax varname [if] [fweight pweight iweight], ///
	by(varlist max=1) ///
	[bref(integer 1)] ///
	[mweight(varlist max=1)] ///
	[comp(string)] /// gap components, used as filter
	[NQuantiles(integer 100)] ///
	[QMIN(integer 1)] ///
	[QMAX(integer 100)] ///
	[RAWUMdiff] /// do not scale by N_A/N_B
	[SAVE(string asis)] * 

quietly {
	preserve
		
		// weight
		local weightvar = (subinstr("`exp'","=","",.))

		// subset
		if ("`if'" != "") keep `if'

		// dx: for by-logic, we just expand the data for `treat' == 0 and assign `treat' == 1
		if ("`comp'" == "dx") {
			keep if `by' == `bref'
			cap drop _expanded
			expand 2, gen(_expanded)
			replace `by' = abs(1 - `bref') if _expanded == 1
			replace `weightvar' = `mweight' if _expanded == 1 // replace weight with matching weight
		}
		
		// allow for quantile mean (or any other stat) estimation'
		// xtile aggregates quantiles if they contain constant values. Fill up to avoid empty cells.
		tempvar quantile
		gen `quantile' = .
		lab var `quantile' "Compared `varlist' quantile between groups (component-specific)"
		tempvar totweight
		forvalues i = 0/1 {
			// quantiles
		    xtile `quantile'_`i' = `varlist' if `by' == `i' [`weight'`exp'], nquantiles(`nquantiles')
			bys `by': egen `totweight' = total(`weightvar')
			bys `by' (`quantile'_`i'): replace `quantile'_`i' = ///
				ceil(sum(`weightvar') * `nquantiles' / `totweight') if `by' == `i'
		    replace `quantile' = `quantile'_`i' if `by' == `i'
			drop `totweight'
		}
		
		// collapse, use sum of weights (passed via `exp') as N
		tempvar meanq
		tempvar nq
		collapse ///
            (mean) `meanq' = `varlist' ///
            (sum) `nq' = `weightvar' ///
            if !mi(`varlist') [`weight'`exp'] ///
            , by(`by' `quantile')
		reshape wide `meanq' `nq', i(`quantile') j(`by')
		
		// gen diff
		tempvar diff
		if ("`comp'" == "db") {
			gen `diff' = `meanq'0 - `meanq'1
		}
		else {
			gen `diff' = `meanq'1 - `meanq'0
		}
		lab var `diff' "Gap"

		// scale D_A/D_B if not otherwise requested
		if (inlist("`comp'", "da", "db") & "`rawumdiff'" == "") {
			replace `diff' = `diff' * (`nq'0/(`nq'0+`nq'1))
		}

		// save temp data
		if ("`save'" != "") {
			drop if !inrange(`quantile', `qmin', `qmax')
			keep `diff' `quantile' // PERHAPS keep group values per quantile with correct labels to allow for manual processing
			rename `diff' diff
			rename `quantile' q		
			save `save'
		}
	restore
}

end


//
// Plot contribution to DA/DB by specified variable
//
/*
 Plot the contribution of each X level to DA/DB (weighted) and absolute difference in the outcome.
*/

cap program drop nopopost_dadb
program define nopopost_dadb
syntax varname [if] [in], ///
	[NOSORT] /// do not sort by depvar
	[DESCending] /// sort descending (as opposed to ascending if nosort is not specified)
	[KEEPALLlevels] /// keep all levels of var (if cond. ignored)
	[FORCE] /// do not check for no. of levels in var
	[nmin(real 1)] /// minimum number of unmatched weighted obs per cat. be printed
	[twopts(string asis)] ///
	[twoptsbar(string asis)] ///
	[twoptsscatter(string asis)] ///
	[twoptsby(string asis)] ///
	[nodraw] ///
	[SAVE(string asis)]

	quietly {
		
		// check if prior command was nopo
		if ("`e(cmd)'" != "nopopost") {
			noisily dis as error "Previous command was not nopopost decomp."
			error 301
			exit
		}

		// plotvar
		tempvar plotby
		clonevar `plotby' = `varlist'
		local _plotbyname `varlist' // for renaming tempvar upon save
		local _plotbylbl : variable label `_plotbyname'

		// check if plotvar is in matching set (otherwise it does not make much sense)
		if (ustrregexm("`e(matchset)'", "\b`_plotbyname'\b") == 0) {
			noisily dis as error "Variable `varlist' not in matching set (`e(matchset)')."
			error 321
			exit
		}
		
		// set input from syntax and nopo returns
		// sample
		tempvar touse
		mark `touse' `if' `in'
		replace `touse' = 0 if !e(sample)
		// depvar
		local _depvar = e(depvar)
		// treatment indicator (fix to 0/1)
		tempvar treat
		gen `treat' = 1 if `e(tvar)' == `e(tval)'
		replace `treat' = 0 if `treat' != 1 & !mi(`e(tvar)')
		local _treatname = e(tvar) // for renaming tempvar upon save
		local _treatlbl : variable label `_treatname'
		lab var `treat' `_treatlbl'
		local _vallbl : value label `_treatname'
		if ("`_vallbl'" != "") {
			label list `_vallbl'
			levelsof `_treatname', local(_bylvls)
			levelsof `_treatname' if `treat' == 1, local(_reflvl)
			foreach _lvl in `_bylvls' {
				local _lbl : label `_vallbl' `_lvl'
				if (`_lvl' == `_reflvl') lab def _bylbl 1 "`_lbl'", modify
					else lab def _bylbl 0 "`_lbl'", modify
			}
			lab val `treat' _bylbl
			local _haslabel
		}
	
		// support
		local _support = e(matched)
		// weights
		if ("`e(wtype)'" != "") {
			local _weightexp "[`e(wtype)' = `e(wexp)']"
			if ("`e(wtype)'" == "pweight") local _sum_weightexp = usubinstr("`_weightexp'", "pweight", "aweight", .)
				else local _sum_weightexp = `_weightexp'
		}
		else {
			tempvar weight
			gen `weight' = 1
			local _weightexp "[aw = `weight']"
		}

		// save levels of plotby
		if ("`keepalllevels'" != "") levelsof `plotby', local(_plotbylvls)
			else levelsof `plotby' if `touse', local(_plotbylvls)

		// check if levels sensible
		local _nplotbylvls : word count `_plotbylvls'
		if ("`force'" == "" & `_nplotbylvls' > 30) {
			noisily dis as error "`plotby' has more than 30 levels. Specify 'force' option to override."
			error 134
			exit
		}

		// relevel plotby: gen variable with no gaps
		// default: sort by depvar
		tempvar plotbyreleveled
		gen `plotbyreleveled' = .
		// gen means
		if ("`nosort'" == "") {	
			preserve
				collapse (mean) `_depvar' `_weightexp', by(`plotby')
				sort `_depvar'
				drop `_depvar'
				tempvar sorter
				if ("`descending'" != "") gen `sorter' = _n
					else gen `sorter' = _N - _n + 1
 				tempfile sorted
				save `sorted'
			restore
			merge m:1 `plotby' using `sorted', nogen
		}	
		// reorder and relabel
		local _plotbyvallbl : value label `plotby'
		local _s = 0
		foreach _l in `_plotbylvls' {
			if ("`nosort'" == "") levelsof `sorter' if `plotby' == `_l', local(_s)
				else local ++_s
			replace `plotbyreleveled' = `_s' if `plotby' == `_l'
			if ("`_plotbyvallbl'" != "") {
				local _lbl : label `varlist' `_l'
				lab def _releveledlbl `_s' "`_lbl'", modify
			}
		}
		lab val `plotbyreleveled' _releveledlbl
		if ("`nosort'" == "") {
			drop `sorter'
			lab var `plotbyreleveled' "`_plotbylbl' releveled by mean `_depvar' `descending'"
		} 
		else {
			lab var `plotbyreleveled' "`_plotbylbl' releveled"
		}
		
		// build plot components
		preserve

			// calculate values by levels of plotby
			cap drop mdepvar_matched
			gen mdepvar_matched = .
			cap drop mdepvar_diff
			gen mdepvar_diff = .
			cap drop mdepvar_diff_weighted
			gen mdepvar_diff_weighted = .
			gen n_weighted = .

			foreach _l in `_plotbylvls' {
				// DA/DB
				forvalues _t = 0/1 {
					sum `_depvar' `_sum_weightexp' if `treat' == `_t' & `_support' == 1 & `touse'
					local _mdepvar_matched = r(mean)
					sum `_depvar' `_sum_weightexp' if `treat' == `_t' & `touse'
					local _wntotal = r(sum_w)
					replace mdepvar_diff = `_depvar' - `_mdepvar_matched' ///
						if `plotby' == `_l' & `treat' == `_t' & `_support' == 0 & `touse'
					replace mdepvar_diff_weighted = mdepvar_diff * (`weight'/`_wntotal') ///
						if `plotby' == `_l' & `treat' == `_t' & `_support' == 0 & `touse'
					count if `treat' == `_t' & `touse'
					replace n_weighted = `weight' * (r(N)/`_wntotal') ///
						if `plotby' == `_l' & `treat' == `_t' & `_support' == 0 & `touse'
				}
			}
			replace mdepvar_diff_weighted = -mdepvar_diff_weighted if `treat' == 1 // reverse for DB

			// check if values the same as in nopo table
			noisily dis "Component sum check:"
			noisily table `treat' if `_support' == 0, stat(sum mdepvar_diff_weighted)

			// keep all levels for plot? 
			// useful if plotted comparisons do not have the same plotby levels due to missings
			if ("`keepalllevels'" == "") keep if `touse' 

			// collapse
			collapse ///
				(mean) mdepvar_diff (sum) mdepvar_diff_weighted ///
				(sum) n_weighted (mean) `plotby' ///
				, by(`plotbyreleveled' `treat')
			replace mdepvar_diff_weighted = . if n_weighted == 0

			if ("`nodraw'" == "") {

				// N as text: get plot area and coordinates from data
				tostring n_weighted, gen(n_weighted_str) format(%9.0f) force
				sum mdepvar_diff
				if (abs(r(max)) > abs(r(min))) local _mmax = abs(r(max)) * 1.75 // make room for obs text
					else local _mmax = abs(r(min)) * 1.75
				sum mdepvar_diff_weighted
				if (abs(r(max)) > abs(r(min))) local _wmmax = abs(r(max)) * 1.75 // make room for obs text
					else local _wmmax = abs(r(min)) * 1.75
				if (`_nplotbylvls'/5 < 1) local _yrangemax = `_nplotbylvls' + 1
					else if (`_nplotbylvls'/5 < 2) local _yrangemax = `_nplotbylvls' + 2
					else local _yrangemax = `_nplotbylvls'/5 + `_nplotbylvls'
				cap drop nx
				gen nx = `_mmax' // x value for n counts (added as mlabel)
				local _text `" text(`_yrangemax' `_mmax' "N unmatched" "(weighted)", place(sw) just(right) size(small) xaxis(2)) "'
				local _ysize = `_nplotbylvls'/5 + 5
				if (`_ysize' < 8) local _xsize = 9
					else local _xsize = 9 + `_ysize'/3

				// set default plot options
				#delimit ;
				if (`"`twopts'"' == "") local twopts `"
					legend(order(
						3 "Contribution of unmatched to D (top x-axis)"
						1 "Category-specific mean of unmatched - overall mean of matched (bottom x-axis)"
						) rows(2) margin(zero)  region(style(none)) size(small))
					ylabel(1(1)`_nplotbylvls', valuelabel grid angle(horizontal) labsize(small))
					yscale(range(`_yrangemax' 1)) ytitle("")
					xscale(range(-`_wmmax' `_wmmax') axis(1))
					xscale(range(-`_mmax' `_mmax') axis(2)) xlab(, axis(2) grid labsize(small))
					xtitle("Difference in means", axis(2) margin(0 0 0 3)) 
					subtitle(, bcolor("237 237 237") margin(1 1 1 1.5))
					scheme(s1mono) xsize(`_xsize') ysize(`_ysize')
					"';
				if (`"`twoptsby'"' == "") local twoptsby `" 
					ixtitle note("") b1title("") graphregion(margin(zero)) 
					"';
				if (`"`twoptsbar'"' == "") local twoptsbar `"
					fcolor(gs10%50) lcolor(gs10) lp(solid) lw(0.2)
					"';
				if (`"`twoptsscatter'"' == "") local twoptsscatter `" 
					mcolor(black) xline(0, lcolor(black) lwidth(0.2)) xaxis(1) 
					xtitle("Contribution of unmatched to D", margin(0 0 3 3)) 
					"';
				#delimit cr

				// plot
				twoway ///
					(bar mdepvar_diff `plotbyreleveled' if n_weighted >= `nmin' ///
						, horizontal xaxis(2) `_text' `twoptsbar') ///
					(scatter `plotbyreleveled' mdepvar_diff_weighted if n_weighted >= `nmin' ///
						, `twoptsscatter') ///
					(scatter `plotbyreleveled' nx ///
						, xaxis(2) mcolor(none) mlabel(n_weighted_str) mlabpos(9) mlabgap(0) ///
						msize(vtiny)) ///
					, by(`treat', `twoptsby') `twopts'
			}

			// save plot data?
			if (`"`save'"' != "") {
				cap drop nx n_weighted_str
				// order, rename and label
				order `treat' `plotby' `plotbyreleveled'
				lab var `plotby' "`_plotbylbl'"
				lab val `plotby' `_plotbyvallbl'
				rename `plotby' `_plotbyname'
				rename `plotbyreleveled' `_plotbyname'_relevel
				lab var `treat' "`_treatlbl'"
				rename `treat' `_treatname'
				rename mdepvar_diff `_depvar'_diff
				lab var `_depvar'_diff "Difference mean unmatched - overall mean of matched"
				rename mdepvar_diff_weighted `_depvar'_diff_weighted
				lab var `_depvar'_diff_weighted "Contribution of unmatched to D"
				lab var n_weighted "N unmatched (weighted)"
				// save
				noisily save `save', replace
			}

		restore
	}

end


//
// Summary table by group/matching status/weight
//
/*
 Build from kmatch summary tables or do our own?
*/

cap program drop nopopost_summarize
program define nopopost_summarize, rclass
syntax [varlist (default=none)] [if] [in], ///
	[STATistics(string)] /// mean mean/sd?
	[label] ///
	[SAVE(string asis)]

	quietly {
		
		// check if prior command was nopo
		if ("`e(cmd)'" != "nopopost") {
			noisily dis as error "Previous command was not nopopost decomp."
			error 301
			exit
		}

		// set input from syntax and nopo returns
		// sample
		tempvar touse
		mark `touse' `if' `in'
		replace `touse' = 0 if !e(sample)
		// depvar
		local _depvar = e(depvar)
		// treatment indicator (fix to 0/1)
		tempvar treat
		gen `treat' = 1 if `e(tvar)' == `e(tval)'
		replace `treat' = 0 if `treat' != 1 & !mi(`e(tvar)')
		// assign correct labels
		local _treatname = e(tvar) // for renaming tempvar upon save
		local _vallbl : value label `_treatname'
		if ("`_vallbl'" != "") {
			label list `_vallbl'
			levelsof `_treatname', local(_bylvls)
			levelsof `_treatname' if `treat' == 1, local(_reflvl)
			foreach _lvl in `_bylvls' {
				local _lbl : label `_vallbl' `_lvl'
				if (`_lvl' == `_reflvl') lab def _bylbl 1 "`_lbl'", modify
					else lab def _bylbl 0 "`_lbl'", modify
			}
			lab val `treat' _bylbl
		}
		// x reference (opposite for b)
		if ("`e(teffect)'" == "ATC") local _bref = 1
			else local _bref = 0
		// support
		local _support = e(matched)
		// matching weights
		local _mweight = e(mweight)
		// weights
		if ("`e(wtype)'" != "") {
			local _weightexp "[`e(wtype)' = `e(wexp)']"
			if ("`e(wtype)'" == "pweight") local _weightexp = usubinstr("`_weightexp'", "pweight", "aweight", .)
		}
		
		// vars to tab; defaults to matching set
		if ("`varlist'" == "") local varlist "`_depvar' `e(matchset)'"
		if ("`statistics'" == "") local statistics "mean sd"

		//
		// create table as matrix
		// provide appropriate names (prefix)

		// A_unmatched
		tabstat `varlist' if `treat' == 0 & `_support' == 0 & `touse' `_weightexp' ///
			, stat(`statistics') save
		mat A_unmatched = r(StatTotal)
		nopopost_stacktbl A_unmatched, `label'
		mat A_unmatched = r(A_unmatched)

		// A_matched
		tabstat `varlist' if `treat' == 0 & `_support' == 1 `_weightexp' & `touse' ///
			, stat(`statistics') save
		mat A_matched = r(StatTotal)
		nopopost_stacktbl A_matched, `label'
		mat A_matched = r(A_matched)

		// A_matched_weighted or B_matched_weighted
		if (`_bref' == 0) {
			// A: b ref group for which treat == 0
			tabstat `varlist' if `treat' == 0 & `_support' == 1 & `touse' [aw = `_mweight'] ///
				, stat(`statistics') save
			local _matweighted = "A_matched_weighted"
		}
		else if (`_bref' == 1) {
			// B: b ref group for which treat == 1
			tabstat `varlist' if `treat' == 1 & `_support' == 1  & `touse' [aw = `_mweight'] ///
				, stat(`statistics') save
			local _matweighted = "B_matched_weighted"
		}
		mat `_matweighted' = r(StatTotal)
		nopopost_stacktbl `_matweighted', `label'
		mat `_matweighted' = r(`_matweighted')

		// B_matched
		tabstat `varlist' if `treat' == 1 & `_support' == 1 `_weightexp' & `touse' ///
			, stat(`statistics') save
		mat B_matched = r(StatTotal)
		nopopost_stacktbl B_matched, `label'
		mat B_matched = r(B_matched)

		// B_unmatched
		tabstat `varlist' if `treat' == 1 & `_support' == 0 `_weightexp' & `touse' ///
			, stat(`statistics') save
		mat B_unmatched = r(StatTotal)
		nopopost_stacktbl B_unmatched, `label'
		mat B_unmatched = r(B_unmatched)

		// combine
		mat _M = A_unmatched, A_matched, `_matweighted', B_matched, B_unmatched

		// label (always provide headings via equations)
		local _colnames : colnames _M, quoted
		local _colnames = usubinstr(`"`_colnames'"', "A_", "A:", .)
		local _colnames = usubinstr(`"`_colnames'"', "B_", "B:", .)
		if ("`label'" != "") {
			if ("`_vallbl'" != "") {
				local _Albl : label _bylbl 0
				local _colnames = usubinstr(`"`_colnames'"', "A:", "`_Albl':", .)
				local _Blbl : label _bylbl 1
				local _colnames = usubinstr(`"`_colnames'"', "B:", "`_Blbl':", .)
			}
			local _colnames = usubinstr(`"`_colnames'"', "_weighted", " & weighted", .)
		}
		mat colnames _M = `_colnames'
		// list and return
		noisily matlist _M, lines(columns) showcoleq(combined)
		return mat npsum = _M

	}

end

// stack tabstat results for multiple statistics into a single column
cap program drop nopopost_stacktbl
program define nopopost_stacktbl, rclass
	syntax namelist (max=1), ///
		[label]

	mat _IN = `namelist'
	local _nrows : rowsof(_IN)
	local _rownames : rownames _IN
	local _ncols : colsof(_IN)
	local _colnames : colnames _IN
	mat _OUT = J(`_nrows' * `_ncols', 1, .)
    
    local _cidx = 0
    foreach _colname in `_colnames' {
        local ++_cidx
        local _ridx = 0
        foreach _rowname in `_rownames' {
            local ++_ridx
			// gather later row names
			if ("`label'" == "") {
				local _stackednames = "`_stackednames' `_colname':`_rowname'"
			}
			else {
				local _lbl : variable label `_colname'
				if ("`_lbl'" == "") local _lbl = "`_colname'"
				local _stackednames = "`_stackednames' `_lbl':`_rowname'"
			}
			// replace values in placeholder matrix
			local _nidx = `_nrows' * (`_cidx' - 1) + `_ridx'
			mat _OUT[`_nidx', 1] = _IN[`_ridx', `_cidx']
		}
	}
	mat rownames _OUT = `_stackednames'
    mat colnames _OUT = `namelist'
    
	// return
	return mat `namelist' = _OUT
	
end